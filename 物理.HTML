<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>高二物理練習 - 測量與不確定度（單題顯示｜20題）</title>
<style>
body{font-family:system-ui,"Microsoft JhengHei",sans-serif;background:#0b1020;color:#e9ecf8;margin:0}
header{padding:16px;background:#111734}
h1{font-size:20px;margin:0}
.panel{background:#111734;padding:16px;border-radius:10px;margin:10px}
.pill{display:inline-block;background:#0f1533;padding:6px 10px;border-radius:999px;margin:2px}
.btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
.btn.secondary{background:#2a3585;color:#fff}
.btn.warn{background:#ffcc66}
.btn.bad{background:#f7768e;color:#fff}
.qcard{background:#0f1533;padding:12px;border-radius:10px;margin-bottom:12px;border:1px solid #232c63}
.choice{padding:8px;border:1px solid #232c63;border-radius:8px;margin:6px 0;cursor:pointer}
.choice.correct{border-color:#55d187;background:#0c1f18}
.choice.wrong{border-color:#f7768e;background:#271018}
.explain{display:none;background:#0f1533;padding:8px;margin-top:8px;border-left:3px solid #2e4284;border-radius:6px}
.explain.show{display:block}
.progress{height:8px;background:#10163a;border-radius:4px;overflow:hidden;margin-bottom:6px}
.bar{height:100%;width:0%;background:linear-gradient(90deg,#7aa2f7,#55d187)}
.small{opacity:.85;font-size:13px}
.tag{display:inline-block;background:#17204a;border:1px solid #2e3a7e;padding:2px 8px;border-radius:999px;font-size:12px;margin-right:6px}
</style>
</head>
<body>
<header>
  <h1>高二物理練習（108課綱）— 第一章｜測量與不確定度（單題顯示｜20題）</h1>
</header>

<div class="panel">
  <span class="pill">模式
    <select id="mode">
      <option value="practice">練習（立即顯示解析）</option>
      <option value="exam">模擬測驗（交卷後一次看解析）</option>
    </select>
  </span>
  <button class="btn" id="startBtn">開始練習</button>
  <button class="btn bad" id="clearBtn">清除進度</button>

  <div class="progress"><div class="bar" id="progressBar"></div></div>
  <div id="progressText" class="small">尚未開始</div>
  <div class="small">正確：<b id="okCount">0</b> ｜ 錯誤：<b id="badCount">0</b></div>
</div>

<div id="questionArea" style="margin:10px;"></div>

<div class="panel" id="navArea" style="display:none;gap:8px">
  <button class="btn secondary" id="prevBtn">上一題</button>
  <button class="btn secondary" id="nextBtn">下一題</button>
  <button class="btn warn" id="submitBtn">交卷</button>
</div>

<div id="resultArea" style="display:none;margin:10px">
  <div class="qcard">
    <h3 style="margin:0 0 8px">成績與解析</h3>
    <div id="scoreLine" class="small"></div>
  </div>
  <div id="reviewArea"></div>
</div>

<script>
// ===== 工具函式 =====
const rndi = (min,max)=>Math.floor(Math.random()*(max-min+1))+min;
const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
const roundSig = (x, sig)=>{
  if (x===0) return "0";
  const m = Number(x);
  const p = Math.ceil(Math.log10(Math.abs(m)));
  const f = sig - p;
  return Number(m.toFixed(Math.max(f,0)));
};
function makeChoicesSmart(correct, genDistractors){
  const set = new Set([correct]);
  let guard = 0;
  while(set.size<4 && guard<30){
    const d = genDistractors();
    if (d!==correct) set.add(d);
    guard++;
  }
  const arr = Array.from(set);
  for (let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  const answer = arr.indexOf(correct);
  return {choices: arr, answer};
}

// ===== 強化版第一章出題器（多題型模板） =====
function gen_t1(){
  const unitLen = pick(["cm","m","mm"]);
  const unitMass = pick(["g","kg"]);
  const unitTime = pick(["s","min"]);
  const template = pick([
    "sig_leading_zero","sig_trailing_no_dot","sig_trailing_with_dot","sig_scientific","sig_round_to_n",
    "add_rule","sub_rule","mul_rule","div_rule","percent_error_abs","percent_error_small"
  ]);

  if (template==="sig_leading_zero"){
    const zeros = rndi(1,3);
    const tail = rndi(100,999);
    const raw = "0." + "0".repeat(zeros) + String(tail);
    const ans = String(tail).replace(/0+$/,'').length;
    const correct = `${ans} 位`;
    const {choices,answer} = makeChoicesSmart(correct, ()=>`${Math.max(1, ans+pick([-2,-1,1,2]))} 位`);
    return {stem:`數值 ${raw} 的有效數字有幾位？`,choices,answer,
      explanation:`前導零不算； ${raw} 去除前導零後計數，尾端非必要的 0 不算入，因此為 ${ans} 位。`,
      life:`電子秤顯示 0.00340 ${unitMass} 時，前面的 0 只是定位，不能算有效數字。`};
  }
  if (template==="sig_trailing_no_dot"){
    const base = pick([100,200,300,400,500,600,700,800,900])*pick([1,10,100]);
    const raw = String(base);
    const ans = 1;
    const correct = `${ans} 位`;
    const {choices,answer} = makeChoicesSmart(correct, ()=>`${pick([2,3,4])} 位`);
    return {stem:`數值 ${raw}（未標示小數點）之有效數字為？`,choices,answer,
      explanation:`未標示小數點且未特別標示的末尾 0 一般不視為有效，僅最高位肯定 → 1 位。`,
      life:`測距寫「3000 m」不帶小數點，多半只代表約略數。`};
  }
  if (template==="sig_trailing_with_dot"){
    const base = pick([1000,2000,3000,4000,5000]);
    const raw = base + ".";
    const ans = String(base).length;
    const correct = `${ans} 位`;
    const {choices,answer} = makeChoicesSmart(correct, ()=>`${pick([ans-1, ans+1, 3])} 位`);
    return {stem:`數值 ${raw} 的有效數字為？`,choices,answer,
      explanation:`有小數點且末尾零表示精度，皆為有效 → ${ans} 位。`,
      life:`量程顯示 3000. ${unitLen}，尾零具意義，代表量測解析度。`};
  }
  if (template==="sig_scientific"){
    const sig = pick([2,3,4]);
    const coeff = (Math.random()*9+1).toFixed(sig-1);
    const p = pick([-3,-2,-1,0,1,2,3]);
    const raw = `${coeff}×10^${p}`;
    const correct = `${sig} 位`;
    const {choices,answer} = makeChoicesSmart(correct, ()=>`${pick([sig-1, sig+1, 3])} 位`);
    return {stem:`科學記號 ${raw} 的有效數字有幾位？`,choices,answer,
      explanation:`科學記號中只看係數 ${coeff} 的位數 → ${sig} 位。`,
      life:`實驗紀錄常以科學記號表達，例如 6.02×10^23。`};
  }
  if (template==="sig_round_to_n"){
    const n = pick([2,3,4]);
    const value = (Math.random()*9000+10).toFixed(pick([2,3,4]));
    const rounded = roundSig(value, n);
    const {choices,answer} = makeChoicesSmart(String(rounded), ()=>{
      const delta = pick([-1,1]);
      return String(roundSig(value, Math.max(1,n+delta)));
    });
    return {stem:`將 ${value} 以「${n} 位有效數字」表示為？`,choices,answer,
      explanation:`依有效位數四捨五入，${value} → ${rounded}（保留 ${n} 位）。`,
      life:`資料表常要求統一位數，便於比較。`};
  }
  if (template==="add_rule"){
    const a = (Math.random()*10).toFixed(pick([0,1,2]));
    const b = (Math.random()*10).toFixed(pick([1,2,3]));
    const worst = Math.min((a.split('.')[1]||'').length,(b.split('.')[1]||'').length);
    const sum = (Number(a)+Number(b)).toFixed(worst);
    const {choices,answer} = makeChoicesSmart(`${sum} ${unitLen}`, ()=>{
      const wrong1 = Number(a)+Number(b);
      return pick([`${wrong1.toFixed(Math.max(worst-1,0))} ${unitLen}`,`${wrong1.toFixed(worst+1)} ${unitLen}`]);
    });
    return {stem:`以加法規則處理：${a} ${unitLen} + ${b} ${unitLen} = ？`,choices,answer,
      explanation:`加法看小數位，取最差者，結果 ${sum} ${unitLen}。`,
      life:`把兩次尺量結果相加，結果的小數位不能比最差的那一次更細。`};
  }
  if (template==="sub_rule"){
    const a = (Math.random()*10+10).toFixed(pick([1,2,3]));
    const b = (Math.random()*10).toFixed(pick([0,1,2]));
    const worst = Math.min((a.split('.')[1]||'').length,(b.split('.')[1]||'').length);
    const val = (Number(a)-Number(b));
    const diff = val.toFixed(worst);
    const {choices,answer} = makeChoicesSmart(`${diff} ${unitLen}`, ()=>{
      return pick([`${val.toFixed(Math.max(worst-1,0))} ${unitLen}`,`${val.toFixed(worst+1)} ${unitLen}`]);
    });
    return {stem:`以減法規則處理：${a} ${unitLen} − ${b} ${unitLen} = ？`,choices,answer,
      explanation:`減法同樣看小數位，取最差者 → ${diff} ${unitLen}。`,
      life:`量兩次時間相減求間隔，表示到與較差者相同的小數位。`};
  }
  if (template==="mul_rule"){
    const aSig = pick([2,3,4]);
    const bSig = pick([2,3,4]);
    const a = roundSig((Math.random()*9+1), aSig);
    const b = roundSig((Math.random()*9+1), bSig);
    const prod = a*b;
    const keep = Math.min(aSig,bSig);
    const out = roundSig(prod, keep);
    const {choices,answer} = makeChoicesSmart(String(out), ()=>String(roundSig(prod, keep+pick([-1,1]))));
    return {stem:`乘法 ${a} × ${b} 應保留？`,choices,answer,
      explanation:`乘法看有效位數，取兩者較少者為 ${keep} 位，故 ≈${out}。`,
      life:`面積＝長×寬，結果有效位數不能超過最少的那一個量測。`};
  }
  if (template==="div_rule"){
    const aSig = pick([2,3,4]);
    const bSig = pick([2,3,4]);
    const a = roundSig((Math.random()*90+10), aSig);
    const b = roundSig((Math.random()*9+1), bSig);
    const q = a/b;
    const keep = Math.min(aSig,bSig);
    const out = roundSig(q, keep);
    const {choices,answer} = makeChoicesSmart(String(out), ()=>String(roundSig(q, keep+pick([-1,1]))));
    return {stem:`除法 ${a} ÷ ${b} 應保留？`,choices,answer,
      explanation:`除法同乘法，取有效位數較少者 → ${keep} 位，故 ≈${out}。`,
      life:`計算密度＝質量/體積，表示位數由最少有效位的量測限制。`};
  }
  if (template==="percent_error_abs"){
    const truev = Math.round(Math.random()*90+10);
    const meas = truev + pick([-5,-3,-2,-1,1,2,3,5]);
    const perror = Math.abs((meas-truev)/truev)*100;
    const correct = `${Number(perror.toFixed(2))}%`;
    const {choices,answer} = makeChoicesSmart(correct, ()=>`${Number((perror*pick([0.5, 2, 1.5])).toFixed(2))}%`);
    return {stem:`真值 ${truev}，量得 ${meas}，百分誤差約為？`,choices,answer,
      explanation:`|測−真|/真×100%≈${correct}。`,
      life:`用捲尺測身高，若尺未頂到牆面，會產生固定方向的誤差。`};
  }
  const truev = Number((Math.random()*0.9+0.1).toFixed(2));
  const meas = Number((truev + (Math.random()*0.2-0.1)).toFixed(2));
  const perror = Math.abs((meas-truev)/truev)*100;
  const correct = `${Number(perror.toFixed(2))}%`;
  const {choices,answer} = makeChoicesSmart(correct, ()=>`${Number((perror*pick([0.5, 2, 0.8, 1.2])).toFixed(2))}%`);
  return {stem:`真值 ${truev}，量得 ${meas}，百分誤差約為？`,choices,answer,
    explanation:`|測−真|/真×100%≈${correct}。真值小時，相同差值會造成較大的百分誤差。`,
    life:`量很短的時間（如反應時間），即使差 0.05 ${unitTime}，相對誤差比例也很高。`};
}

// ===== 狀態 =====
let bank=[], idx=0, done=false, ok=0, bad=0;
const questionArea=document.getElementById('questionArea'), navArea=document.getElementById('navArea'),
resultArea=document.getElementById('resultArea'), scoreLine=document.getElementById('scoreLine'),
reviewArea=document.getElementById('reviewArea'), okCountEl=document.getElementById('okCount'),
badCountEl=document.getElementById('badCount'), bar=document.getElementById('progressBar'),
progressText=document.getElementById('progressText');

// ===== 渲染單題 =====
function renderOne(){
  const q=bank[idx];
  questionArea.innerHTML='';
  const card=document.createElement('div');
  card.className='qcard';
  card.innerHTML=`<div class="small"><span class="tag">第一章</span> 第 ${idx+1} / ${bank.length} 題</div>
    <div style="margin:6px 0 10px">${q.stem}</div>
    <div id="choices"></div>
    <div class="explain" id="explain"><b>詳解：</b>${q.explanation}<br><b>生活化例子：</b>${q.life}</div>`;
  const ch=card.querySelector('#choices');
  q.choices.forEach((c,j)=>{
    const opt=document.createElement('div');
    opt.className='choice';
    opt.dataset.choice=String(j);
    opt.innerHTML=`<b>${'ABCD'[j]}</b> ${c}`;
    ch.appendChild(opt);
  });
  if(q.userAnswered!==undefined){
    const items=ch.querySelectorAll('.choice');
    items.forEach((el,j)=>{
      if(j===q.answer) el.classList.add('correct');
      if(j===q.userAnswered && j!==q.answer) el.classList.add('wrong');
    });
    document.getElementById('explain').classList.add('show');
  }
  questionArea.appendChild(card);
  updateProgress();
}

// ===== 事件委派 =====
questionArea.addEventListener('click',e=>{
  if(done
